;
; BASE_DEVICE GeoPIXE raw data device superclass.
;
; All device object classes depend on this superclass
; DO NOT EDIT THIS FILE. Notify CSIRO of any issues/suggestions.
; 
; The following device classes have been built on this base class:
; Use their methods, or define a new device class, to access data.
; Do not use base_device directly.
; 
;	New device Obj			  Old device list:							     old index
;	MPSYS_DEVICE			'MARC MPsys - Linux data acquisition'				; 0
;	LUND_KMAX_DEVICE		'Lund KMax - MAC data acquisition'					; 1
;	NAC_XSYS_DEVICE			'NAC XSYS - VAX data acquisition'					; 2
;	MPSYS_UNIX_DEVICE		'MARC MPsys - Unix data acquisition'				; 3
;	OM_DAQ_DEVICE			'OM DAQ - PC data acquisition'						; 4
;	SANDIA_EVT_DEVICE		'Sandia EVT - PC data acquisition'					; 5
;	SANDIA_MPAWIN_DEVICE	'Sandia MPAWIN - PC data acquisition'				; 6
;	FASTCOM_MPA3_DEVICE 	'Fastcom MPA3 - PC data acquisiion'					; 7
;	APS_LST_DEVICE			'APS Data Cube - LST reformatted on PC'				; 8
;	SANDIA_BD12_DEVICE		'Sandia Rontec BD12 - PC data acquisition'			; 9
;	NSLS_MCA_DEVICE			'NSLS MCA - VME data acquisition'					; 10
;	TOHOKU_LABO_DEVICE		'Tohoku Labo - PC data acquisition'					; 11
;	PRIMECORE_U48_DEVICE	'Sandia Primecore U48 - PC data acquisition'		; 12
;	ZAGREB_LST_DEVICE		'Zagreb LST - PC data acquisition'					; 13
;	GSE_CARS_MCA_DEVICE		'GSE-CARS MCA - VME data acquisition'				; 14
;	HASYLAB_FIO_DEVICE		'Hasylab FIO - ASCII pixel data'					; 15
;	MAIA_DEVICE				'Maia 384/96 - HYMOD data acquisition'				; 16
;	NSLS_HDF_DEVICE			'NSLS HDF - SXRF image data file'					; 17
;	SLS_MCA_DEVICE			'SLS MCA - SXRF image data file'					; 18
;	ESRF_EDF_DEVICE			'ESRF EDF - SXRF image data file'					; 19
;	CSIRO_MIN_DEVICE		'CSIRO minerals - EMP image data file'				; 20
;	WAKASA_UNIDAQ_DEVICE	'Wakasa UniDAQ - PC data acquisition'				; 21
;	HORIBA_RAW_DEVICE		'Horiba raw - XRF image data file'					; 22
;	NSLS_NETCDF_DEVICE		'NSLS NetCDF - SXRF image data file'				; 23
;
; Always use or define a new device class, that is built on this BASE_DEVICE super-class.
; Never use the base class directly. If a method is not written for a new class, the base
; class method will be used. This obviates the need to write many simple methods.
; 
;----------------------------------------------------------------------------
; 
; Writing and using device methods. Use features of existing device object define
; files as a guide. Do not base a new device object on the base device code here.
;
; Initialization:
; When all device classes are detected and loaded into GeoPIXE (all files of the
; form "xxx_device__define.sav" or "xxx_device__define.pro" in the "interface"
; sub-directory of the GeoPIXE main directory, excluding 'BASE_DEVICE"), an 
; Object reference is created for each using the IDL call "Obj_New('xxx_device')".
; This executes the "Init" method in the class.
; 
; init()			initialize the class definition and also defines the main 
; 					object parameter struct in the "xxx_device__define" routine.
; 					DO NOT RUN THIS METHOD (it is done by IDL).
; cleanup			this is run when an object is destroyed (DO NOT RUN THIS METHOD)
; 
; Reading list-mode data to produce images and spectra:
; All device object classes need to implement these methods, with a full parameter
; list (even if some parameters are not used).
;
; read_setup()		will be called after each data file that is opened to setup
;					internal device parameters needed for reading data buffers,
;					such as buffer size and device-specific buffer organization.
; read_buffer()		called repeatedly to read buffers from the data file, process
;					these to extract X,Y,E triplet data, tagged by detector channel,
;					compress X,Y,E if needed, and optionally detect other
;					information (e.g. flux/charge, energy tokens). 
; get_header_info()	interrogate the data files (usually prior to starting processing)
; 					for various details, such as scan size (physical size and/or
; 					pixel count), title, energy cal for detectors, etc.
;
; The above 3 methods (plus the init and cleanup methods) are the minimum set needed 
; to be written for a new device class.
;
; flux_scan()		scan the raw data-files for details of available ion chamber 
; 					specifications (e.g. EPICS PVs) to provide for user selection, and 
; 					select one to use, and the pre-amp sensitivity value and units.
; trim_evt_files()	trim the list of files to only include files needed for the Y range
; 					seen in the region mask arrays (used with EVT button on Image Regions window).
;					Y LUT for Maia is a list of first Y value for each blog data file.
; check_pv_list		checks a list of parameter names (PVs) and adds any internal names
; 					that are missing and are supported (internally) by the device.
;
; Import of various device-specific spectra formats:
; The "Spectrum Display" window "File->Import" menu can provide access to various routines
; for reading local device-specific spectrum data formats. It also provides access for
; scanning the list-mode data to extract all spectrum information (this is handled internally
; in GeoPIXE. The two routines providing this access are:
; 
; get_import_list()	returns a vector of structs specifiying various properties of the
; 					spectrum import (or list-mode spectrum extract) routines.
; 					(look at these routines below for details of these structs and various
; 					examples).
; import_spec()		calls the selected external import routine to read local spectral data.
; 
; Base-device methods available:
; Some general purpose methods are provided by the BASE_DEVICE master-class, so you don't
; need to write these for each device class (call from your class code using e.g.
; "self->big_endian()"). These are:
;
; name()				return name of device (e.g. "NSLS_MCA_DEVICE").
; title()				return title string for this device (used in Sort EVT droplist)
; extension()			return raw data file extension (if fixed, else '')
; multi_files()			1=data organized in multiple files, else=0
; multi_char()			character used to separate run name/number from numeric data-file series
; big_endian()			1=flags data stored in raw data in Big Endian byte order, else=0
; vax_float()			1=flags VAX D-floating variables as part of data header
; start_adc()			# of the first detector ADC.
; pileup()				1=flags the use of a pileup rejection file for this device
; throttle()			1=f;ags the use of a Throttle mechanism for this device
; linear()				1=flags a linearization correction table used for this device
; cluster()				1=flags support for cluster parallel processing
; use_bounds()			1=flags that this device may have a border of pixels that contain
;						no data and no beam charge/flux that should be excluded from pixel count.
; ylut()				1=flags that this device can use and generate a lookup table of 
;						first Y for each member of a multi-file data series to speed up
;						certain operations (e.g. spectra extract using EVT button on Image Regions window).
;
; The values for these setting are set-up in the device Init method, in a call to
; the BASE_DEVICE super-class Init method. 
; 
; Other options that can be flagged are the use of pileup, throttle, linearization, and the
; use of a Y lookup table, which can be flagged this way:
;
;	self.pileup.use = 1
;	self.throttle.use = 1
;	self.linear.use = 1
;	self.header.scan.use_ylut = 1
;
; Device specific parameters:
; The following methods need to be written for any new device that supports a Y lookup table (YLUT).
; The base device methods here just return an error and no YLUT.
;
; get_ylut()			retrieve the Y lookup table data from file (meth
; build_ylut			build a YLUT from raw data files.
; write_ylut			write a Y lookup table file (called from the DA image sort).
;
; The following methods need to be written for a device for optional time handling.
; 
; get_dwell()		Return the internal device dwell (ms) image array. The array must
; 					be set-up in the init method.
; get_total_time()	Return the internal elapsed time to normalize dead_fraction in 
; 					spectra imports (default = 1.0). Use this in a device if it 
; 					accumulates dT per event that need to be ratioed to total time.
; get_deadtime_cal()  The Maia device has time-over-threshold (T) digitized for each pulse.
; 					The deadtime cal provides a conversion to realtime (ns) as
;					dt = cal.a * T + cal.b. This method returns a default struct with cal.a=1
; 					for devices that don't provide a calibration method.
; 					
; If the device has some device specific parameters that need to be set-up for
; processing and read/written along with image and region data, etc. then use this
; facility to define widgets to gather info about parameter options and manage them.
; If you don't need them, do not define these methods. Then a default (no action)
; method will be used in the "BASE_DEVICE" master-class. See the code in the Maia_device
; as an example.
; 
; These options are set-up in widgets that appear in the Sort EVT options box on the
; Sort tab. The parameters live in the class 'self' struct and are handled by GeoPIXE
; using these methods:
;
; render_options	Draws widgets needed in supplied parent base (on Sort tab).
; read_options		Called when images and regions are read from disk to read
;					the device specific options into the object self struct.
; write_options		Called when images and regions are written to disk to write
;					the device specific options from the object self struct.
; options_legend()	Returns a formatted string array to be added to the
;					image history list in the Image History window.
;
; To use these widgets and methods, enable the options by setting the following in
; your class 'init' method:
; 
; 	self.options.scan.on = 1			; enable options wdigets
; 	self.options.scan.ysize = 100		; Y size of sort options box, when open
; 	
; If you need to set or get your options parameters from your class, you can define these
; methods (see examples in Maia_device). They are not essential and are NOT called
; from GeoPIXE:
; 
; set_options		Explicitly pass these options parameters into the object.
;					This is only used to transfer old version file data in
;					and should be avoided normally.
; get_options()		Explicitly get options parameters from object.
;					Avoid using this.		
;
; The following two are used with Options widgets, but are handled by the Base super-class:
; 
; show_sort_options()  Flags that this device has sort options to display.
; get_sort_ysize()	   Returns number of Y pixels needed for device options fields.
;
; The code in the render_options for creating options widgets for the Maia device,
; which also calls some OnRealize routines and an event handler, can be used as a model
; for new device options fields.
;
;--------------------------------------------------------------------------------------------

pro base_device::cleanup

COMPILE_OPT STRICTARR
ErrorNo = 0
common c_errors_1, catch_errors_on
if n_elements(catch_errors_on) eq 0 then catch_errors_on=1
if catch_errors_on then begin
	Catch, ErrorNo
	if (ErrorNo ne 0) then begin
		Catch, /cancel
		on_error, 1
		help, calls = s
		n = n_elements(s)
		c = 'Call stack: '
		if n gt 2 then c = [c, s[1:n-2]]
		warning,'base_device::cleanup',['IDL run-time error caught.', '', $
				'Error:  '+strtrim(!error_state.name,2), $
				!error_state.msg,'',c], /error
		MESSAGE, /RESET
		return
	endif
endif

	if ptr_valid( self.options) then begin
		n = n_elements( *self.options)
		if n gt 0 then begin
			for i=0L,n-1 do begin
				opt = (*self.options)[i]
				if ptr_valid( opt.plist) then ptr_free, opt.plist
			endfor
		endif
		ptr_free, self.options
	endif
	if ptr_valid( self.header.px_coords) then ptr_free, self.header.px_coords
	if ptr_valid( self.header.py_coords) then ptr_free, self.header.py_coords
	if ptr_valid( self.header.pz_coords) then ptr_free, self.header.pz_coords
	if ptr_valid( self.header.scan.pYlut) then ptr_free, self.header.scan.pYlut
	if ptr_valid( self.import_list) then ptr_free, self.import_list
	if ptr_valid( self.old_mp) then ptr_free, self.old_mp
    return
end

;-------------------------------------------------------------------

; Name of device object

function base_device::name

COMPILE_OPT STRICTARR
		
	return, self.name
end
;-------------------------------------------------------------------

; title string for device object, to use in droplist

function base_device::title

COMPILE_OPT STRICTARR
		
	return, self.title
end
;-------------------------------------------------------------------

; File extension for raw data files for any device object

function base_device::extension

COMPILE_OPT STRICTARR
		
	return, self.ext
end
;-------------------------------------------------------------------

; Does this device object support multiple data files

function base_device::multi_files

COMPILE_OPT STRICTARR
		
	return, self.multi_files
end
;-------------------------------------------------------------------

; File separator for multifile data files for any device object

function base_device::multi_char

COMPILE_OPT STRICTARR
		
	return, self.multi_char
end
;-------------------------------------------------------------------

; Indicates an object with detector number implicitly embedded in the file-name

function base_device::embed_detector

	COMPILE_OPT STRICTARR

	return, (self.embed_detector eq 1)
end

;-------------------------------------------------------------------

; Return the index 'q' to 'files' selected for cluster 'cluster_index' out of 'cluster_total'

function base_device::cluster_files, files, cluster_total, cluster_index, nq=nq

	COMPILE_OPT STRICTARR

	if n_elements(files) eq 0 then goto, bad
	if n_elements(cluster_total) eq 0 then goto, bad
	if n_elements(cluster_index) eq 0 then goto, bad

	q1 = indgen(cluster_total)
	q1 = congrid( q1, n_elements(files), /center)
	q2 = where(q1 eq cluster_index, nq)	

	return, q2

bad:
	nq = 0L
	return, -1L
end

;-------------------------------------------------------------------

; Does this device object have big-endian byte order data files

function base_device::big_endian

COMPILE_OPT STRICTARR
		
	return, self.big_endian
end
;-------------------------------------------------------------------

; Does this device object have VAX D-floating in data files

function base_device::vax_float

COMPILE_OPT STRICTARR
		
	return, self.vax_float
end
;-------------------------------------------------------------------

; Starting ADC # for this device object
;
; 'start_adc' subtleties:
;	0	Means ADC channel number is the same in the hardware and binary raw data files
;		as displayed in droplists, etc, in GeoPIXE.
;	1	Means that ADC channel displayed as "1" occurs in raw data files as "0".

function base_device::start_adc

COMPILE_OPT STRICTARR
		
	return, self.start_adc
end

;-------------------------------------------------------------------

; Does this device object set to detector array mode by default?
; Use in tests: if obj->array_default() 

function base_device::array_default

COMPILE_OPT STRICTARR
		
	return, self.array_default
end

;-------------------------------------------------------------------

; Does this device object use a Flip X option?
; Use in tests: if obj->flipX() 

function base_device::flipX

COMPILE_OPT STRICTARR
		
	return, 0
end

;-------------------------------------------------------------------

; Does this device object use a Flip Y option?
; Use in tests: if obj->flipY() 

function base_device::flipY

COMPILE_OPT STRICTARR
		
	return, 0
end

;-------------------------------------------------------------------

; Is the flip (swap) ICR-RAW on?
; Use in tests: if obj->flip_icr_raw() 

function base_device::flip_icr_raw

COMPILE_OPT STRICTARR
		
	return, 0
end

;-------------------------------------------------------------------

; Does this device object use a pileup file specifier?
; Use in tests: if obj->pileup() 

function base_device::pileup

COMPILE_OPT STRICTARR
		
	return, self.pileup.use
end

;-------------------------------------------------------------------

; Does this device object use a throttle file specifier?
; Use in tests: if obj->throttle() 

function base_device::throttle

COMPILE_OPT STRICTARR
		
	return, self.throttle.use
end

;-------------------------------------------------------------------

; Does this device object use a linearization file specifier?
; Use in tests: if obj->linear() 

function base_device::linear

COMPILE_OPT STRICTARR
		
	return, self.linear.use
end

;-------------------------------------------------------------------

; Does this device object support cluster parallel processing?
; Use in tests: if obj->cluster() 

function base_device::cluster

COMPILE_OPT STRICTARR
		
	return, self.use_cluster
end

;-------------------------------------------------------------------

; Does this device object use the bounds to define a sub-area that all
; beam charge is assumed to lie within?
; Use in tests: if obj->use_bounds() ...

function base_device::use_bounds

COMPILE_OPT STRICTARR
		
	return, self.use_bounds
end

;-------------------------------------------------------------------

; Scan raw data files for device specific flux IC PV information
 
pro base_device::flux_scan, unit, evt_file, PV_list, IC_name, IC_val, IC_vunit, dwell=dwell, $
			image_mode=image_mode, group=group, suppress=suppress, $
			no_pv=no_pv, use_dwell=use_dwell, error=error

; Scan raw data files for flux IC PV information
; 
; Input:
; 	unit		I/O unit open
; 	evt_file	file-name of opened file
; 	group		group-leader parent window to pass to any pop-up windows
;
;	/Image_mode	scan data for PVs for an image, with dwell
;	/Suppress	suppress pop-ups

; Return:
; 	PV_list		string list of all PV's found that may be used to measure flux/IC count
; 	IC_name		PV selected by user from list
; 	IC_val		pre-amp sensitivity value
; 	IC_vunit	pre-amp sensitivity unit multipler
; 	dwell		dwell-time in a pixel (ms), if needed
; 	no_pv		flags absence of any PVs
;	use_dwell	flags need to use dwell in flux count measure

	return
end

;-------------------------------------------------------------------

pro base_device::check_pv_list, plist

; Check the PV string list pointed to by 'plist'. Add any device internal PVs
; not present to this list. The ones corresponding to the 'get_attributes'
; must appear first in the list.

COMPILE_OPT STRICTARR

	return
end

;-------------------------------------------------------------------

; Indicates that this device needs to build a Y lookup table in a single
; pass from all files. 

function base_device::incremental_ylut

COMPILE_OPT STRICTARR
		
	return, 0
end

;-------------------------------------------------------------------

; Indicates that this device support a Y lookup table that matches the Y value
; at the start of each raw EVT list-mode data-file. The device must support 
; 'multi_files' mode. Set-up this flag in the init method for a new device
; (don't do it in base_device) as well as a pointer (w/ allocated heap) to hold
; the YLUT itself. 

function base_device::ylut

COMPILE_OPT STRICTARR
		
	return, self.header.scan.use_ylut
end

;-------------------------------------------------------------------

; Read a Y lookup table file that lists the first Y value
; for each list-mode data file. None supported by base device.
; However, your own device may implement this method 
; (see Maia device example).
 
pro base_device::build_ylut, file, output=output, error=error, force=force

COMPILE_OPT STRICTARR

	error = 1
	return
end

;-------------------------------------------------------------------

; Read a Y lookup table file that lists the first Y value
; for each list-mode data file. None supported by base device.
; However, your own device may implement this method 
; (see Maia device example).
 
function base_device::get_ylut, file, strip=strip, output=output, error=error

COMPILE_OPT STRICTARR

	error = 1
	return, 0L
end

;-------------------------------------------------------------------

; Delete a Y lookup table file that lists the first Y value
; for each list-mode data file.
 
pro base_device::delete_ylut, ylut, file, output=output, error=error

COMPILE_OPT STRICTARR

	error = 1
	return
end

;-------------------------------------------------------------------

; Write a Y lookup table file.
 
pro base_device::write_ylut, ylut, file, output=output, strip=strip, error=error

COMPILE_OPT STRICTARR

	error = 1
	return
end

;-------------------------------------------------------------------

function base_device::get_dwell, error=error

; No internal dwell (ms) image array by default. However, your own device may
; implement this method (see Maia device example).

COMPILE_OPT STRICTARR

	error = 1
	return, 0.0
end

;-------------------------------------------------------------------

function base_device::get_dead_weight, error=error

; No internal dead-time weight image array by default. However, your own device may
; implement this method (see FalconX device example).

COMPILE_OPT STRICTARR

	error = 1
	return, 0.0
end

;-------------------------------------------------------------------

function base_device::get_dead_weight_mode

; No internal dead-time weight image array by default. However, your own device may
; implement this method (see FalconX device example).
;
; Return the internal dead-time weight mode (affects appropach in GeoPIXE):
;		0	weight is incoming count estimate (simple weight norm)
;		1	weight is outgoing raw count weight (final dead-fraction = r/(1+r), where r=dead/weight)
;		2	Dead time is not implemented (yet) or disabled

COMPILE_OPT STRICTARR

	return, 0
end

;-------------------------------------------------------------------

function base_device::get_total_time, error=error

; Return the internal elapsed time to normalize dead_fraction
; in 'spec_evt', (default = 1.0). Use this in a device if it accumulates
; flux counts that need to be ratioed to total time.

COMPILE_OPT STRICTARR

	error = 0
	return, self.dwell_total
end

;-------------------------------------------------------------------

; The Maia and DAQ devices use SCEPTER for time-over-threshold (T) digitized for each pulse.
; The deadtime cal provides a conversion to realtime (ns) as
;		dt = cal.a * T + cal.b
; This method returns a default struct with cal.a=1
; for devices that don't provide a calibration method.
; Some device may return more calibration data in 'more'

function base_device::get_deadtime_cal, more=more, error=error

COMPILE_OPT STRICTARR

	error = 0	
	return, {a:1.0, b:0.0}
end

;-------------------------------------------------------------------

; Trim the list of files to only include files needed for the Y range
; seen in the region mask arrays.
 
function base_device::trim_evt_files, files, mask=pmask, pYlut=pYlut, $
								yoffset=yoffset, yrange=yrange

; Trim the list of 'files' to only include files needed for the Y range
; and offset selected, or as seen in the region mask arrays.
;
; yoffset	Y offset (not compressed)
; yrange	Y range (not compressed)
; pmask		ptr to region mask ptr array
; pYlut		pointer to Y LUT for raw data files

COMPILE_OPT STRICTARR

	return, files
end

;-------------------------------------------------------------------

;	For some devices, the dead_fraction, flux and dwell maps my be noisy.
;	The dwell and weight get smoothed in the "get" method calls.
;	Here we need to explicitly smooth flux.

function base_device::smooth_flux, flux

COMPILE_OPT STRICTARR

	return, flux
end

;-------------------------------------------------------------------

;	For some devices, the accumulated flux may be multiply counted.
;	This method is used to count the passes.

function base_device::pass_count

COMPILE_OPT STRICTARR

	return, 1
end

;-------------------------------------------------------------------

;	For some devices, the dead_fraction, flux and dwell maps my be noisy.
;	The dwell and weight get smoothed in the "get" method calls.
;	Here we need to explicitly smooth weight.

function base_device::smooth_weight, weight

COMPILE_OPT STRICTARR

	return, weight
end

;-------------------------------------------------------------------

; The "options" are widgets and parameters associated with the Sort tab
; of the Sort EVT window. These should be defined in the sub-class elsewhere
; in a "render_options" method and their parameters set using "set_options".
; If the call ends here, that means that no methods have been defined in the
; sub-class and so nothing is done here.

pro base_device::set_options, maia

COMPILE_OPT STRICTARR

	return
end

;-------------------------------------------------------------------

; The "options" are widgets and parameters associated with the Sort tab
; of the Sort EVT window. These should be defined in the sub-class elsewhere
; in a "render_options" method and their parameters set using "set_options".
; If the call ends here, that means that no methods have been defined in the
; sub-class and so nothing is done here.

function base_device::get_options, error=error

COMPILE_OPT STRICTARR

	error = 0
	return, 0
end

;-------------------------------------------------------------------

; In certain devices this method is called after the 'get_header_info()' method
; has been called (e.g. when raw data files are first referenced) to update any
; internal device parameters if they also occur in the header.

pro base_device::update_device_from_header, error=error

COMPILE_OPT STRICTARR

	error = 0
	return
end

;-------------------------------------------------------------------

; The "options" are widgets and parameters associated with the Sort tab
; of the Sort EVT window. These should be defined in the sub-class elsewhere
; in a "render_options" method and their parameters read from image/region
; files in the class "read_options" method. If the call ends here, that
; means that no methods have been defined in the 
; sub-class and so nothing is done here.

pro base_device::read_options, unit, discard=discard, options=options, error=error

COMPILE_OPT STRICTARR
ErrorNo = 0
common c_errors_1, catch_errors_on
if n_elements(catch_errors_on) eq 0 then catch_errors_on=1
if catch_errors_on then begin
	Catch, ErrorNo
	if (ErrorNo ne 0) then begin
		Catch, /cancel
		on_error, 1
		help, calls = s
		n = n_elements(s)
		c = 'Call stack: '
		if n gt 2 then c = [c, s[1:n-2]]
		warning,'base_device::read_options',['IDL run-time error caught.', '', $
				'Error:  '+strtrim(!error_state.name,2), $
				!error_state.msg,'',c], /error
		MESSAGE, /RESET
		return
	endif
endif

	version = 0L
	
	on_ioerror, bad_io
	if self.use_version then readu, unit, version
	
	options = 0L
	error = 0
	return
	
bad_io:
	error = 1
	return
end

;-------------------------------------------------------------------

; The "options" are widgets and parameters associated with the Sort tab
; of the Sort EVT window. These should be defined in the sub-class elsewhere
; in a "render_options" method and their parameters written to image/region
; files in the class "write_options" method. If the call ends here, that
; means that no methods have been defined in the 
; sub-class and so nothing is done here.
;
;	Always read/write a version number.
;	Conditional code in a device will read/write more if version is NOT zero.

pro base_device::write_options, unit, options=options, error=error

COMPILE_OPT STRICTARR
ErrorNo = 0
common c_errors_1, catch_errors_on
if n_elements(catch_errors_on) eq 0 then catch_errors_on=1
if catch_errors_on then begin
	Catch, ErrorNo
	if (ErrorNo ne 0) then begin
		Catch, /cancel
		on_error, 1
		help, calls = s
		n = n_elements(s)
		c = 'Call stack: '
		if n gt 2 then c = [c, s[1:n-2]]
		warning,'base_device::write_options',['IDL run-time error caught.', '', $
				'Error:  '+strtrim(!error_state.name,2), $
				!error_state.msg,'',c], /error
		MESSAGE, /RESET
		return
	endif
endif

	version = 0L
	
	on_ioerror, bad_io
	writeu, unit, version
	error = 0
	return
	
bad_io:
	error = 1
	return
end

;-------------------------------------------------------------------

; Does this device object have additional Sort options to display?
; Use in tests: if obj->show_sort_options() ... to display scan option fields

function base_device::show_sort_options

COMPILE_OPT STRICTARR
		
	return, self.options.scan.on
end

;-------------------------------------------------------------------

; The "options" are widgets and parameters associated with the Sort tab
; of the Sort EVT window. These should be defined in the sub-class elsewhere
; in a "render_options" method and their parameters set using "set_options".
; If the call ends here, that means that no methods have been defined in the
; sub-class and so nothing is done here, except to clear any widgets.

pro base_device::render_options, parent

COMPILE_OPT STRICTARR
ErrorNo = 0
common c_errors_1, catch_errors_on
if n_elements(catch_errors_on) eq 0 then catch_errors_on=1
if catch_errors_on then begin
	Catch, ErrorNo
	if (ErrorNo ne 0) then begin
		Catch, /cancel
		on_error, 1
		help, calls = s
		n = n_elements(s)
		c = 'Call stack: '
		if n gt 2 then c = [c, s[1:n-2]]
		warning,'base_device::render_options',['IDL run-time error caught.', '', $
				'Error:  '+strtrim(!error_state.name,2), $
				!error_state.msg,'',c], /error
		MESSAGE, /RESET
		return
	endif
endif

; If an existing set of options are being displayed, kill these ...

	child = widget_info( parent, /child)
	if widget_info( child, /valid) then widget_control, child, /destroy
	
	widget_control, parent, scr_ysize = self.options.scan.ysize > 1
	return
end

;-------------------------------------------------------------------

; Return size of scan option fields

function base_device::get_sort_ysize

COMPILE_OPT STRICTARR
		
	return, self.options.scan.ysize
end

;-------------------------------------------------------------------------------

; Null Sort options legend string

function base_device::options_legend, p

COMPILE_OPT STRICTARR

	return, ''
end

;-------------------------------------------------------------------

; Register to send a Notify out to 'tlb' in order to update other GUI
; elements when something changes in the device (e.g. axis changes).

pro base_device::register_notify, tlb, message, from=from

COMPILE_OPT STRICTARR
ErrorNo = 0
common c_errors_1, catch_errors_on
if n_elements(catch_errors_on) eq 0 then catch_errors_on=1
if catch_errors_on then begin
	Catch, ErrorNo
	if (ErrorNo ne 0) then begin
		Catch, /cancel
		on_error, 1
		help, calls = s
		n = n_elements(s)
		c = 'Call stack: '
		if n gt 2 then c = [c, s[1:n-2]]
		warning,'base_device::register_notify',['IDL run-time error caught.', '', $
				'Error:  '+strtrim(!error_state.name,2), $
				!error_state.msg,'',c], /error
		MESSAGE, /RESET
		return
	endif
endif
if n_elements(tlb) eq 0 then tlb=0L
if n_elements(message) eq 0 then message=''
if n_elements(from) eq 0 then from=0L
		
	self.options.notify.on = 1
	if widget_info(tlb,/valid) eq 0 then self.options.notify.on = 0
	if widget_info(from,/valid) eq 0 then self.options.notify.on = 0
	self.options.notify.tlb = tlb
	self.options.notify.from = from
	self.options.notify.message = message
	if self.options.notify.on eq 0 then return
	
	register_notify, tlb, message, from=from
	return
end

;-------------------------------------------------------------------

; Send a registered Notify out to 'tlb' in order to update other GUI
; elements when something changes in the device (e.g. axis changes).

pro base_device::update_notify

COMPILE_OPT STRICTARR
ErrorNo = 0
common c_errors_1, catch_errors_on
if n_elements(catch_errors_on) eq 0 then catch_errors_on=1
if catch_errors_on then begin
	Catch, ErrorNo
	if (ErrorNo ne 0) then begin
		Catch, /cancel
		on_error, 1
		help, calls = s
		n = n_elements(s)
		c = 'Call stack: '
		if n gt 2 then c = [c, s[1:n-2]]
		warning,'base_device::update_notify',['IDL run-time error caught.', '', $
				'Error:  '+strtrim(!error_state.name,2), $
				!error_state.msg,'',c], /error
		MESSAGE, /RESET
		return
	endif
endif

;	print,'Notify from device:'
;	help, self	
;	help, self.options.notify, /str
	if self.options.notify.on eq 0 then return
	if widget_info(self.options.notify.tlb, /valid) eq 0 then return
	notify, self.options.notify.message, from=self.options.notify.from
	return
end

;-------------------------------------------------------------------

; Set state of versioning. For internal use ONLY.
;	0	versioning off (for old file compatibility only)
;	1	versioning on, which means that read/write of device specific options parameters
;		will write/read a version number first, and read can do some version specific
;		things (e.g. read more options based on version [see Maia device for example]).
;		This is the default, so read_options/write_options should read/write a version number first
;		as shown by default methods in base device.

pro base_device::set_versioning, ver

COMPILE_OPT STRICTARR
if n_elements(ver) eq 0 then ver=1
		
	self.use_version = ver
	return
end

;-------------------------------------------------------------------

; Set state of versioning.
;	0	versioning off
;	1	versioning on, which means that read/write of device specific options parameters
;		will write/read a version number first, and read can do some version specific
;		things (e.g. read more options based on version [see Maia device for example]).
;
;	By default versioning has been enabled for image versions <= -39.

pro base_device::get_version, image_start=image_start

COMPILE_OPT STRICTARR
if n_elements(image_start) eq 0 then image_start=1
		
	self.use_version = ver
	return
end

;-------------------------------------------------------------------

; Return a code that indicates what audience this object is for?
; 1=ion-beam, 2=synchrotron, 3=both

function base_device::beam_type

COMPILE_OPT STRICTARR
		
	return, self.ionbeam + 2* self.synchrotron
end

;-------------------------------------------------------------------

; Indicates an ionbeam object

function base_device::ionbeam

	COMPILE_OPT STRICTARR

	return, (self.ionbeam eq 1)
end

;-------------------------------------------------------------------

; Indicates an synchrotron object

function base_device::synchrotron

	COMPILE_OPT STRICTARR

	return, (self.synchrotron eq 1)
end

;-------------------------------------------------------------------

; This method is called to see if there are extra data/detector planes that should be
; accumulated. It returns yheir name strings.
; The 'read_buffer' method should accumulate these as extra planes of the 'flux'
; array if the flux array is passed with 3 dimensions.

function base_device::get_attribute_list, error=error

; error=1 and return '' for no list by default

COMPILE_OPT STRICTARR

	error = 1
	return, ''
end

;-------------------------------------------------------------------

; Sub-classes may define a data file header method, if not we do nothing here.

function base_device::get_header_info, file, output=output, silent=silent, error=error

; file		a raw data file to look for associated header, metadata
; output	if present, this is a file on the output path, if some metadata is
;			located in that path (e.g. Maia Y LUT). 
; /silent	suppress any pop-ups.

COMPILE_OPT STRICTARR

;	mp = ... load local device data ... ( file, error=error)
;	if error then return,0
;
;	self->save_header_data, mp
;	self->update_header_info, error=error
;	if error then return,0
;
;	self.header.error = 0
;	error = 0
;	return, self.header
		
	error = 1
	return, 0
end

;-------------------------------------------------------------------

; Save local device data for use to build a header.

pro base_device::save_header_data, mp

COMPILE_OPT STRICTARR
ErrorNo = 0
common c_errors_1, catch_errors_on
if n_elements(catch_errors_on) eq 0 then catch_errors_on=1
if catch_errors_on then begin
	Catch, ErrorNo
	if (ErrorNo ne 0) then begin
		Catch, /cancel
		on_error, 1
		help, calls = s
		n = n_elements(s)
		c = 'Call stack: '
		if n gt 2 then c = [c, s[1:n-2]]
		warning,'base_device::save_header_data',['IDL run-time error caught.', '', $
				'Error:  '+strtrim(!error_state.name,2), $
				!error_state.msg,'',c], /error
		MESSAGE, /RESET
		return
	endif
endif
	
	*self.old_mp = mp
	return
end

;-------------------------------------------------------------------

; A sub-class method will freeze changes to options.

pro base_device::change_options, flag, error=error

COMPILE_OPT STRICTARR
		
	error = 0
	return
end

;-------------------------------------------------------------------

; A sub-class method will update header based on local device data saved
; in old_mp.

pro base_device::update_header_info, error=error

COMPILE_OPT STRICTARR
		
	self.header.error = 0
	error = 1
	return
end

;-------------------------------------------------------------------

; Map from stored data and return current header struct.

function base_device::show_header, error=error

COMPILE_OPT STRICTARR
ErrorNo = 0
common c_errors_1, catch_errors_on
if n_elements(catch_errors_on) eq 0 then catch_errors_on=1
if catch_errors_on then begin
	Catch, ErrorNo
	if (ErrorNo ne 0) then begin
		Catch, /cancel
		on_error, 1
		help, calls = s
		n = n_elements(s)
		c = 'Call stack: '
		if n gt 2 then c = [c, s[1:n-2]]
		warning,'base_device::show_header',['IDL run-time error caught.', '', $
				'Error:  '+strtrim(!error_state.name,2), $
				!error_state.msg,'',c], /error
		MESSAGE, /RESET
		return,0
	endif
endif
		
	self->update_header_info, error=error
	if error then return,0
	return, self.header
end

;-------------------------------------------------------------------

; This is just to set the header struct to a previously saved copy.
; Use this while populating a new Dev Object with parameters from another.
; Take care: The input 'header' must be a clone of a valid self.header struct,
; probably obtained from the 'show_header' or 'get_header_info()' methods.

pro base_device::set_header, header

COMPILE_OPT STRICTARR
ErrorNo = 0
common c_errors_1, catch_errors_on
if n_elements(catch_errors_on) eq 0 then catch_errors_on=1
if catch_errors_on then begin
	Catch, ErrorNo
	if (ErrorNo ne 0) then begin
		Catch, /cancel
		on_error, 1
		help, calls = s
		n = n_elements(s)
		c = 'Call stack: '
		if n gt 2 then c = [c, s[1:n-2]]
		warning,'base_device::set_header',['IDL run-time error caught.', '', $
				'Error:  '+strtrim(!error_state.name,2), $
				!error_state.msg,'',c], /error
		MESSAGE, /RESET
		return
	endif
endif
		
	p1 = ptr_new( header)
	copy_pointer_data, p1, p2, /init
	
	self.header = *p2
	ptr_free, p1,p2
	return
end

;-------------------------------------------------------------------

function base_device::import_spec, name, file, group=group

COMPILE_OPT STRICTARR

	return, 0L
end

;-------------------------------------------------------------------

function base_device::get_import_list, error=error

COMPILE_OPT STRICTARR

	error = 1
	return, 0L
end

;-------------------------------------------------------------------

; Init method, not called directly, only when an object is defined using
; obj = obj_new('name'). This should happen in sub-class, which may set core
; parameters by calling the base_device super-class here.
; Do not modify these. Notify CSIRO of any issues/suggestions.

function base_device::init, name=name, title=title, ext=ext, multi_files=multi_files, $
	multi_char=multi_char, big_endian=big_endian, vax_float=vax_float, use_bounds=use_bounds, $
	start_adc=start_adc, synchrotron=synchrotron, ionbeam=ionbeam, $
	use_cluster=use_cluster, array_default=array_default

COMPILE_OPT STRICTARR
ErrorNo = 0
common c_errors_1, catch_errors_on
if n_elements(catch_errors_on) eq 0 then catch_errors_on=1
if catch_errors_on then begin
	Catch, ErrorNo
	if (ErrorNo ne 0) then begin
		Catch, /cancel
		on_error, 1
		help, calls = s
		n = n_elements(s)
		c = 'Call stack: '
		if n gt 2 then c = [c, s[1:n-2]]
		warning,'base_device::init',['IDL run-time error caught.', '', $
				'Error:  '+strtrim(!error_state.name,2), $
				!error_state.msg,'',c], /error
		MESSAGE, /RESET
		return,0
	endif
endif

	if strpos( STRUPCASE(name), '_DEVICE') eq -1 then begin
		warning,'base_device::init','Device Object name must end in "_DEVICE".'
		return, 0
	endif
	if n_elements(name) lt 1 then return, 0
	if n_elements(title) lt 1 then title=name + ' device object'
	if n_elements(ext) lt 1 then ext=''
	if n_elements(multi_files) lt 1 then multi_files=0
	if n_elements(multi_char) lt 1 then multi_char=''
	if n_elements(big_endian) lt 1 then big_endian=0
	if n_elements(vax_float) lt 1 then vax_float=0
	if n_elements(start_adc) lt 1 then start_adc=0
	if n_elements(synchrotron) lt 1 then synchrotron=0
	if n_elements(ionbeam) lt 1 then ionbeam=0
	if n_elements(use_bounds) lt 1 then use_bounds=0
	if n_elements(use_cluster) lt 1 then use_cluster=0
	if n_elements(array_default) lt 1 then array_default=0
	if synchrotron eq 0 then ionbeam=1

	self.header.deadtime_cal.a = 0.0
	
	self.name =	STRUPCASE(name)		; unique name for this device object (object def file should have name: name__define.pro/sav)
	self.title = title				; title as it appears on device droplists
	self.ext = 	ext					; file extension for raw data files
	self.multi_files = multi_files	; flags multiple raw data files per run
	self.multi_char = multi_char	; separates run from segment number in file name
	self.big_endian = big_endian	; raw data byte order
	self.vax_float = vax_float		; flags VAX floating point in data
	self.start_adc = start_adc		; starting # detector ADC's
	self.synchrotron = synchrotron	; synchrotron data
	self.ionbeam = ionbeam			; ion-beam data
	self.use_bounds = use_bounds	; system confines charge/flux within bounded area
	self.use_cluster = use_cluster	; able to use cluster parallel processing
	self.array_default = array_default	; device uses detector arrays by default
	
	self.old_mp = ptr_new( /allocate_heap)	; allocate memory for the old /mp for header	
	return, 1
end

;-------------------------------------------------------------------

pro base_device__define

; Define base GeoPIXE device object superclass internal data structures.
; DO NOT MODIFY THESE. Notify CSIRO of any issues/suggestions.

COMPILE_OPT STRICTARR
ErrorNo = 0
common c_errors_1, catch_errors_on
if n_elements(catch_errors_on) eq 0 then catch_errors_on=1
if catch_errors_on then begin
	Catch, ErrorNo
	if (ErrorNo ne 0) then begin
		Catch, /cancel
		on_error, 1
		help, calls = s
		n = n_elements(s)
		c = 'Call stack: '
		if n gt 2 then c = [c, s[1:n-2]]
		warning,'base_device::define',['IDL run-time error caught.', '', $
				'Error:  '+strtrim(!error_state.name,2), $
				!error_state.msg,'',c], /error
		MESSAGE, /RESET
		return
	endif
endif
common c_base_device, base_device_avail
common c_geopixe_adcs, geopixe_max_adcs
if n_elements(base_device_avail) lt 1 then base_device_avail=0
if base_device_avail then return
if n_elements(geopixe_max_adcs) lt 1 then startupp

; The first group of parameters are set by a call to the Init method from
; the sub-class Init method.
;
; 'start_adc' subtleties:
;	0	Means ADC channel number is the same in the hardware and binary raw data files
;		as displayed in droplists, etc, in GeoPIXE.
;	1	Means that ADC channel displayed as "1" occurs in raw data files as "0".

device = {BASE_DEVICE,  $
		name:			'', $			; device unique short name
		title:			'', $			; device title (used in device droplist)
		ext:			'', $			; device raw data file extension
		multi_files:	0, $			; flags multiple raw data files for an image run
		multi_char:		'', $			; char before multifile number
		big_endian:		0, $			; DAQ computer byte order (1=big endian, 0=little endian)
		vax_float: 		0, $			; DAQ computer uses old VAX D floating point
		start_adc:		0, $			; start detector ADC # (see notes above)
		use_bounds:		0, $			; system confines charge/flux within the bounded area
		synchrotron:	0, $			; "1" for synchrotron data
		ionbeam:		0, $			; "1" for ion-beam data
		array_default:	0, $			; "1" if the device uses detector arrays by default

; Set these "use" parameters to "1" to enable use of the following in processing:
; pileup	low,high time-over-threshold limits (ToT) for each E
; throttle	pre-scale factors for each energy that have been applied by DAQ system
; linear	linearization corrections to apply (seldom used now).

		pileup: {pileup_devicespec, $
				use:	0}, $			; gather pileup file name, and use it
		throttle: {throttle_devicespec, $
				use:	0}, $			; gather throttle file name, and use it
		linear: {linear_devicespec, $
				use:	0}, $			; gather linearization file name, and use it
			
; Set options.scan.on if you have widgets set-up for "render_options" method
; to gather device specific parameters on the Sort tab of the Sort EVT window.
; Ysize is the combined height of all your sort_options widgets. 

		options: {options_devicespec, $
				scan: {options_scan_devicespec, $
					on:		0, $		; scan options active (details in sub-class)
					ysize: 	0}, $		; scan options Y size, when open
				notify: {options_notify_devicespec, $
					on:		0, $		; Enable a Notify to be sent
					tlb:	0L, $		; to this 'tlb', when needed for flow-on updates
					from:	0L, $		; from this tlb
					message: ''}}, $	; message to send
		
; This flags the ability of the device to support cluster processing

		use_cluster:	0, $			; use cluster processing
		
; This flags the use of versioning in the read/write of options parameters. It is mostly
; used to cater for older device files, such as older Maia files.

		use_version:	1, $			; use versioning by default (internal use only)
		
; This pointer holds any spectra import options gathered by get_import_list() method.

		import_list:	ptr_new(), $	; import spectra details list

; This group is for internal accounting in the device for dead-time, etc. If the
; 'read_buffer' method returns 'dead_fraction' as a fraction, then set 'dwell_total=1.0'. If it 
; returns the total time dead in 'dead_fraction', then set 'dwell_total' to the total real time.

		spectrum_mode:		0, $		; 1 indicates spectrum mode, else images
		dwell_total:		0.0, $		; total elapsed time or norm factor (for spectra only)

; The header struct details gathered by get_header_info() methods in the sub-class.
		
		header: {header_devicespec, $
			charge:		0.0, $			; beam charge (uC)
			energy:		0.0, $			; beam energy (MeV: ion-beam, keV: SXRF)
			title:		'', $			; comment/title string
			sample:		'', $			; sample name
			grain:		'', $			; sub-sample/grain ID
			
			metadata: {metadata_devicespec, $
				sample_type:	'', $	; sample type ("standard", "user", ...)
				sample_serial:	'', $	; sample serial/ID code string
				facility:		'', $	; facility string
				endstation:		'', $	; endstation string
				detector_identity: ''}, $ ; detector identity code string
				
			scan: {scan_devicespec, $
				on:			0, $		; scan active
				x_pixels:	0L, $		; # X pixels
				y_pixels:	0L, $		; # Y pixels
				z_pixels:	0L, $		; # Z pixels
				x:			0.0, $		; X absolute origin (mm)
				y:			0.0, $		; Y absolute origin (mm)
				z:			0.0, $		; Z absolute origin (mm)
				x_mm:		0.0, $		; X size of scan (mm)
				y_mm:		0.0, $		; Y size of scan (mm)
				z_mm:		0.0, $		; Z size of scan (mm)
				x_on:		0, $		; X axis in use
				y_on:		0, $		; Y axis in use
				z_on:		0, $		; Z axis in use
				x_name:		'', $		; X axis name
				y_name:		'', $		; Y axis name
				z_name:		'', $		; Z axis name
				mode:		0, $		; scan mode (0 XY, 1 Xstep, 3 Ystep)
				n_steps:	0, $		; number of steps per pixel
				step_size:	0.0, $		; step size in step mode
				sort_mode:	0, $		; sort mode (0 XY image, 1 Traverse)
				dwell:		0.0, $		; dwell time (ms)
				use_ylut:	0, $		; device able to filter file list based on Y LUT
				pYlut:		ptr_new()}, $	; Y lookup table
				
			deadtime_cal: {deadtime_cal_devicespec, $
							a:0.0, b:0.0}, $	; deadtime cal parameters
			
			pileup: {pileup_header_devicespec, on:0, file:'', found:0 }, $			; pileup used and file-name
			throttle: {throttle_header_devicespec, on:0, file:'', found:0 }, $		; throttle used and file-name
							
			sensitivity:	0.0, $				; if using indirect 'charge' via a counter, then charge = conv * flux * sensitivity
			IC_name:		'', $				; name of IC channel/PV
			
			px_coords:		ptr_new(), $		; X coords array
			py_coords:		ptr_new(), $		; Y coords array
			pz_coords:		ptr_new(), $		; Z coords array
			x_coord_units:	'', $				; X coord units
			y_coord_units:	'', $				; Y coord units
			z_coord_units:	'', $				; Z coord units
			
			detector:		intarr(geopixe_max_adcs), $ ; as defined in "detector_types()" 'PIXE','PIGE','RBS','ERDA','STIM','CHARGE','DEADTIME','SXRF','SEM'
			cal:			replicate( {cal_devicespec, on:0, a:0.0, b:0.0, units:''}, geopixe_max_adcs), $
			error:			0 }, $				; header error flag
				
		old_mp:			ptr_new(), $	; store old local device raw header data

		embed_detector:		0 $			; "1" to embed det# in filename (set these to make a variant
		}								; allow a device to set det# for each file from a field ("_ddd_") in filename
		
	base_device_avail = 1
	return
end
